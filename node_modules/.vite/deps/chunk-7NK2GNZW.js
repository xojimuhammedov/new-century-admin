import {
  require_react
} from "./chunk-FDMQADGV.js";
import {
  __commonJS,
  __esm,
  __export,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var init_extends = __esm({
  "node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var init_objectSpread2 = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectSpread2.js"() {
    init_defineProperty();
  }
});

// node_modules/rc-util/es/hooks/useMemo.js
function useMemo(getValue2, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
var React;
var init_useMemo = __esm({
  "node_modules/rc-util/es/hooks/useMemo.js"() {
    React = __toESM(require_react());
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE2 || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE2:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef2 = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE2;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment2(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE2;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo2(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef2;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment2;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo2;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/rc-util/es/React/isFragment.js
function isFragment(object) {
  return (
    // Base object type
    object && _typeof(object) === "object" && // React Element type
    (object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) && // React Fragment type
    object.type === REACT_FRAGMENT_TYPE
  );
}
var REACT_ELEMENT_TYPE_18, REACT_ELEMENT_TYPE_19, REACT_FRAGMENT_TYPE;
var init_isFragment = __esm({
  "node_modules/rc-util/es/React/isFragment.js"() {
    init_typeof();
    REACT_ELEMENT_TYPE_18 = Symbol.for("react.element");
    REACT_ELEMENT_TYPE_19 = Symbol.for("react.transitional.element");
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  }
});

// node_modules/rc-util/es/ref.js
function isReactElement(node) {
  return (0, import_react.isValidElement)(node) && !isFragment(node);
}
var import_react, import_react_is, ReactMajorVersion, fillRef, composeRef, useComposeRef, supportRef, supportNodeRef, getNodeRef;
var init_ref = __esm({
  "node_modules/rc-util/es/ref.js"() {
    init_typeof();
    import_react = __toESM(require_react());
    import_react_is = __toESM(require_react_is());
    init_useMemo();
    init_isFragment();
    ReactMajorVersion = Number(import_react.version.split(".")[0]);
    fillRef = function fillRef2(ref, node) {
      if (typeof ref === "function") {
        ref(node);
      } else if (_typeof(ref) === "object" && ref && "current" in ref) {
        ref.current = node;
      }
    };
    composeRef = function composeRef2() {
      for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
        refs[_key] = arguments[_key];
      }
      var refList = refs.filter(Boolean);
      if (refList.length <= 1) {
        return refList[0];
      }
      return function(node) {
        refs.forEach(function(ref) {
          fillRef(ref, node);
        });
      };
    };
    useComposeRef = function useComposeRef2() {
      for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        refs[_key2] = arguments[_key2];
      }
      return useMemo(function() {
        return composeRef.apply(void 0, refs);
      }, refs, function(prev, next) {
        return prev.length !== next.length || prev.every(function(ref, i) {
          return ref !== next[i];
        });
      });
    };
    supportRef = function supportRef2(nodeOrComponent) {
      var _type$prototype, _nodeOrComponent$prot;
      if (!nodeOrComponent) {
        return false;
      }
      if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) {
        return true;
      }
      var type = (0, import_react_is.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
      if (typeof type === "function" && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type.$$typeof !== import_react_is.ForwardRef) {
        return false;
      }
      if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== import_react_is.ForwardRef) {
        return false;
      }
      return true;
    };
    supportNodeRef = function supportNodeRef2(node) {
      return isReactElement(node) && supportRef(node);
    };
    getNodeRef = function getNodeRef2(node) {
      if (node && isReactElement(node)) {
        var ele = node;
        return ele.props.propertyIsEnumerable("ref") ? ele.props.ref : ele.ref;
      }
      return null;
    };
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
var init_arrayWithHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
var init_objectWithoutPropertiesLoose = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
var init_objectWithoutProperties = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"() {
    init_objectWithoutPropertiesLoose();
  }
});

// node_modules/rc-util/es/warning.js
function warning(valid, message) {
  if (!valid && console !== void 0) {
    var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
      return preMessageFn(msg !== null && msg !== void 0 ? msg : "", "warning");
    }, message);
    if (finalMessage) {
      console.error("Warning: ".concat(finalMessage));
    }
  }
}
function note(valid, message) {
  if (!valid && console !== void 0) {
    var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
      return preMessageFn(msg !== null && msg !== void 0 ? msg : "", "note");
    }, message);
    if (finalMessage) {
      console.warn("Note: ".concat(finalMessage));
    }
  }
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning, valid, message);
}
function noteOnce(valid, message) {
  call(note, valid, message);
}
var warned, preWarningFns, preMessage, warning_default;
var init_warning = __esm({
  "node_modules/rc-util/es/warning.js"() {
    warned = {};
    preWarningFns = [];
    preMessage = function preMessage2(fn) {
      preWarningFns.push(fn);
    };
    warningOnce.preMessage = preMessage;
    warningOnce.resetWarned = resetWarned;
    warningOnce.noteOnce = noteOnce;
    warning_default = warningOnce;
  }
});

// node_modules/rc-util/es/Dom/canUseDom.js
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var init_canUseDom = __esm({
  "node_modules/rc-util/es/Dom/canUseDom.js"() {
  }
});

// node_modules/rc-util/es/Dom/contains.js
function contains(root, n) {
  if (!root) {
    return false;
  }
  if (root.contains) {
    return root.contains(n);
  }
  var node = n;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
var init_contains = __esm({
  "node_modules/rc-util/es/Dom/contains.js"() {
  }
});

// node_modules/rc-util/es/Dom/dynamicCSS.js
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
  if (mark) {
    return mark.startsWith("data-") ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter(function(node) {
    return node.tagName === "STYLE";
  });
}
function injectCSS(css) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority;
  var mergedOrder = getOrder(prepend);
  var isPrependQueue = mergedOrder === "prependQueue";
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, mergedOrder);
  if (isPrependQueue && priority) {
    styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
  }
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css;
  var container = getContainer(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (isPrependQueue) {
      var existStyle = (option.styles || findStyles(container)).filter(function(node) {
        if (!["prepend", "prependQueue"].includes(node.getAttribute(APPEND_ORDER))) {
          return false;
        }
        var nodePriority = Number(node.getAttribute(APPEND_PRIORITY) || 0);
        return priority >= nodePriority;
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer(option);
  return (option.styles || findStyles(container)).find(function(node) {
    return node.getAttribute(getMark(option)) === key;
  });
}
function removeCSS(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var existNode = findExistNode(key, option);
  if (existNode) {
    var container = getContainer(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer(container, option) {
  var cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS(css, key) {
  var originOption = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer(originOption);
  var styles = findStyles(container);
  var option = _objectSpread2(_objectSpread2({}, originOption), {}, {
    styles
  });
  syncRealContainer(container, option);
  var existNode = findExistNode(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css) {
      existNode.innerHTML = css;
    }
    return existNode;
  }
  var newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}
var APPEND_ORDER, APPEND_PRIORITY, MARK_KEY, containerCache;
var init_dynamicCSS = __esm({
  "node_modules/rc-util/es/Dom/dynamicCSS.js"() {
    init_objectSpread2();
    init_canUseDom();
    init_contains();
    APPEND_ORDER = "data-rc-order";
    APPEND_PRIORITY = "data-rc-priority";
    MARK_KEY = "rc-util-key";
    containerCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/@ant-design/fast-color/es/FastColor.js
function splitColorStr(str, parseNum) {
  const match = str.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [];
  const numList = match.map((item) => parseFloat(item));
  for (let i = 0; i < 3; i += 1) {
    numList[i] = parseNum(numList[i] || 0, match[i] || "", i);
  }
  if (match[3]) {
    numList[3] = match[3].includes("%") ? numList[3] / 100 : numList[3];
  } else {
    numList[3] = 1;
  }
  return numList;
}
function limitRange(value, max) {
  const mergedMax = max || 255;
  if (value > mergedMax) {
    return mergedMax;
  }
  if (value < 0) {
    return 0;
  }
  return value;
}
var round, parseHSVorHSL, FastColor;
var init_FastColor = __esm({
  "node_modules/@ant-design/fast-color/es/FastColor.js"() {
    init_defineProperty();
    round = Math.round;
    parseHSVorHSL = (num, _, index) => index === 0 ? num : num / 100;
    FastColor = class _FastColor {
      constructor(input) {
        _defineProperty(this, "isValid", true);
        _defineProperty(this, "r", 0);
        _defineProperty(this, "g", 0);
        _defineProperty(this, "b", 0);
        _defineProperty(this, "a", 1);
        _defineProperty(this, "_h", void 0);
        _defineProperty(this, "_s", void 0);
        _defineProperty(this, "_l", void 0);
        _defineProperty(this, "_v", void 0);
        _defineProperty(this, "_max", void 0);
        _defineProperty(this, "_min", void 0);
        _defineProperty(this, "_brightness", void 0);
        function matchFormat(str) {
          return str[0] in input && str[1] in input && str[2] in input;
        }
        if (!input) {
        } else if (typeof input === "string") {
          let matchPrefix = function(prefix) {
            return trimStr.startsWith(prefix);
          };
          const trimStr = input.trim();
          if (/^#?[A-F\d]{3,8}$/i.test(trimStr)) {
            this.fromHexString(trimStr);
          } else if (matchPrefix("rgb")) {
            this.fromRgbString(trimStr);
          } else if (matchPrefix("hsl")) {
            this.fromHslString(trimStr);
          } else if (matchPrefix("hsv") || matchPrefix("hsb")) {
            this.fromHsvString(trimStr);
          }
        } else if (input instanceof _FastColor) {
          this.r = input.r;
          this.g = input.g;
          this.b = input.b;
          this.a = input.a;
          this._h = input._h;
          this._s = input._s;
          this._l = input._l;
          this._v = input._v;
        } else if (matchFormat("rgb")) {
          this.r = limitRange(input.r);
          this.g = limitRange(input.g);
          this.b = limitRange(input.b);
          this.a = typeof input.a === "number" ? limitRange(input.a, 1) : 1;
        } else if (matchFormat("hsl")) {
          this.fromHsl(input);
        } else if (matchFormat("hsv")) {
          this.fromHsv(input);
        } else {
          throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(input));
        }
      }
      // ======================= Setter =======================
      setR(value) {
        return this._sc("r", value);
      }
      setG(value) {
        return this._sc("g", value);
      }
      setB(value) {
        return this._sc("b", value);
      }
      setA(value) {
        return this._sc("a", value, 1);
      }
      setHue(value) {
        const hsv = this.toHsv();
        hsv.h = value;
        return this._c(hsv);
      }
      // ======================= Getter =======================
      /**
       * Returns the perceived luminance of a color, from 0-1.
       * @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
       */
      getLuminance() {
        function adjustGamma(raw) {
          const val = raw / 255;
          return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
        }
        const R = adjustGamma(this.r);
        const G = adjustGamma(this.g);
        const B = adjustGamma(this.b);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
      }
      getHue() {
        if (typeof this._h === "undefined") {
          const delta = this.getMax() - this.getMin();
          if (delta === 0) {
            this._h = 0;
          } else {
            this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
          }
        }
        return this._h;
      }
      getSaturation() {
        if (typeof this._s === "undefined") {
          const delta = this.getMax() - this.getMin();
          if (delta === 0) {
            this._s = 0;
          } else {
            this._s = delta / this.getMax();
          }
        }
        return this._s;
      }
      getLightness() {
        if (typeof this._l === "undefined") {
          this._l = (this.getMax() + this.getMin()) / 510;
        }
        return this._l;
      }
      getValue() {
        if (typeof this._v === "undefined") {
          this._v = this.getMax() / 255;
        }
        return this._v;
      }
      /**
       * Returns the perceived brightness of the color, from 0-255.
       * Note: this is not the b of HSB
       * @see http://www.w3.org/TR/AERT#color-contrast
       */
      getBrightness() {
        if (typeof this._brightness === "undefined") {
          this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3;
        }
        return this._brightness;
      }
      // ======================== Func ========================
      darken(amount = 10) {
        const h = this.getHue();
        const s = this.getSaturation();
        let l = this.getLightness() - amount / 100;
        if (l < 0) {
          l = 0;
        }
        return this._c({
          h,
          s,
          l,
          a: this.a
        });
      }
      lighten(amount = 10) {
        const h = this.getHue();
        const s = this.getSaturation();
        let l = this.getLightness() + amount / 100;
        if (l > 1) {
          l = 1;
        }
        return this._c({
          h,
          s,
          l,
          a: this.a
        });
      }
      /**
       * Mix the current color a given amount with another color, from 0 to 100.
       * 0 means no mixing (return current color).
       */
      mix(input, amount = 50) {
        const color = this._c(input);
        const p = amount / 100;
        const calc = (key) => (color[key] - this[key]) * p + this[key];
        const rgba = {
          r: round(calc("r")),
          g: round(calc("g")),
          b: round(calc("b")),
          a: round(calc("a") * 100) / 100
        };
        return this._c(rgba);
      }
      /**
       * Mix the color with pure white, from 0 to 100.
       * Providing 0 will do nothing, providing 100 will always return white.
       */
      tint(amount = 10) {
        return this.mix({
          r: 255,
          g: 255,
          b: 255,
          a: 1
        }, amount);
      }
      /**
       * Mix the color with pure black, from 0 to 100.
       * Providing 0 will do nothing, providing 100 will always return black.
       */
      shade(amount = 10) {
        return this.mix({
          r: 0,
          g: 0,
          b: 0,
          a: 1
        }, amount);
      }
      onBackground(background) {
        const bg = this._c(background);
        const alpha = this.a + bg.a * (1 - this.a);
        const calc = (key) => {
          return round((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha);
        };
        return this._c({
          r: calc("r"),
          g: calc("g"),
          b: calc("b"),
          a: alpha
        });
      }
      // ======================= Status =======================
      isDark() {
        return this.getBrightness() < 128;
      }
      isLight() {
        return this.getBrightness() >= 128;
      }
      // ======================== MISC ========================
      equals(other) {
        return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
      }
      clone() {
        return this._c(this);
      }
      // ======================= Format =======================
      toHexString() {
        let hex = "#";
        const rHex = (this.r || 0).toString(16);
        hex += rHex.length === 2 ? rHex : "0" + rHex;
        const gHex = (this.g || 0).toString(16);
        hex += gHex.length === 2 ? gHex : "0" + gHex;
        const bHex = (this.b || 0).toString(16);
        hex += bHex.length === 2 ? bHex : "0" + bHex;
        if (typeof this.a === "number" && this.a >= 0 && this.a < 1) {
          const aHex = round(this.a * 255).toString(16);
          hex += aHex.length === 2 ? aHex : "0" + aHex;
        }
        return hex;
      }
      /** CSS support color pattern */
      toHsl() {
        return {
          h: this.getHue(),
          s: this.getSaturation(),
          l: this.getLightness(),
          a: this.a
        };
      }
      /** CSS support color pattern */
      toHslString() {
        const h = this.getHue();
        const s = round(this.getSaturation() * 100);
        const l = round(this.getLightness() * 100);
        return this.a !== 1 ? `hsla(${h},${s}%,${l}%,${this.a})` : `hsl(${h},${s}%,${l}%)`;
      }
      /** Same as toHsb */
      toHsv() {
        return {
          h: this.getHue(),
          s: this.getSaturation(),
          v: this.getValue(),
          a: this.a
        };
      }
      toRgb() {
        return {
          r: this.r,
          g: this.g,
          b: this.b,
          a: this.a
        };
      }
      toRgbString() {
        return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
      }
      toString() {
        return this.toRgbString();
      }
      // ====================== Privates ======================
      /** Return a new FastColor object with one channel changed */
      _sc(rgb, value, max) {
        const clone = this.clone();
        clone[rgb] = limitRange(value, max);
        return clone;
      }
      _c(input) {
        return new this.constructor(input);
      }
      getMax() {
        if (typeof this._max === "undefined") {
          this._max = Math.max(this.r, this.g, this.b);
        }
        return this._max;
      }
      getMin() {
        if (typeof this._min === "undefined") {
          this._min = Math.min(this.r, this.g, this.b);
        }
        return this._min;
      }
      fromHexString(trimStr) {
        const withoutPrefix = trimStr.replace("#", "");
        function connectNum(index1, index2) {
          return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);
        }
        if (withoutPrefix.length < 6) {
          this.r = connectNum(0);
          this.g = connectNum(1);
          this.b = connectNum(2);
          this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;
        } else {
          this.r = connectNum(0, 1);
          this.g = connectNum(2, 3);
          this.b = connectNum(4, 5);
          this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;
        }
      }
      fromHsl({
        h,
        s,
        l,
        a
      }) {
        this._h = h % 360;
        this._s = s;
        this._l = l;
        this.a = typeof a === "number" ? a : 1;
        if (s <= 0) {
          const rgb = round(l * 255);
          this.r = rgb;
          this.g = rgb;
          this.b = rgb;
        }
        let r = 0, g = 0, b = 0;
        const huePrime = h / 60;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
        if (huePrime >= 0 && huePrime < 1) {
          r = chroma;
          g = secondComponent;
        } else if (huePrime >= 1 && huePrime < 2) {
          r = secondComponent;
          g = chroma;
        } else if (huePrime >= 2 && huePrime < 3) {
          g = chroma;
          b = secondComponent;
        } else if (huePrime >= 3 && huePrime < 4) {
          g = secondComponent;
          b = chroma;
        } else if (huePrime >= 4 && huePrime < 5) {
          r = secondComponent;
          b = chroma;
        } else if (huePrime >= 5 && huePrime < 6) {
          r = chroma;
          b = secondComponent;
        }
        const lightnessModification = l - chroma / 2;
        this.r = round((r + lightnessModification) * 255);
        this.g = round((g + lightnessModification) * 255);
        this.b = round((b + lightnessModification) * 255);
      }
      fromHsv({
        h,
        s,
        v,
        a
      }) {
        this._h = h % 360;
        this._s = s;
        this._v = v;
        this.a = typeof a === "number" ? a : 1;
        const vv = round(v * 255);
        this.r = vv;
        this.g = vv;
        this.b = vv;
        if (s <= 0) {
          return;
        }
        const hh = h / 60;
        const i = Math.floor(hh);
        const ff = hh - i;
        const p = round(v * (1 - s) * 255);
        const q = round(v * (1 - s * ff) * 255);
        const t = round(v * (1 - s * (1 - ff)) * 255);
        switch (i) {
          case 0:
            this.g = t;
            this.b = p;
            break;
          case 1:
            this.r = q;
            this.b = p;
            break;
          case 2:
            this.r = p;
            this.b = t;
            break;
          case 3:
            this.r = p;
            this.g = q;
            break;
          case 4:
            this.r = t;
            this.g = p;
            break;
          case 5:
          default:
            this.g = p;
            this.b = q;
            break;
        }
      }
      fromHsvString(trimStr) {
        const cells = splitColorStr(trimStr, parseHSVorHSL);
        this.fromHsv({
          h: cells[0],
          s: cells[1],
          v: cells[2],
          a: cells[3]
        });
      }
      fromHslString(trimStr) {
        const cells = splitColorStr(trimStr, parseHSVorHSL);
        this.fromHsl({
          h: cells[0],
          s: cells[1],
          l: cells[2],
          a: cells[3]
        });
      }
      fromRgbString(trimStr) {
        const cells = splitColorStr(trimStr, (num, txt) => (
          // Convert percentage to number. e.g. 50% -> 128
          txt.includes("%") ? round(num / 100 * 255) : num
        ));
        this.r = cells[0];
        this.g = cells[1];
        this.b = cells[2];
        this.a = cells[3];
      }
    };
  }
});

// node_modules/@ant-design/fast-color/es/types.js
var init_types = __esm({
  "node_modules/@ant-design/fast-color/es/types.js"() {
  }
});

// node_modules/@ant-design/fast-color/es/index.js
var es_exports = {};
__export(es_exports, {
  FastColor: () => FastColor
});
var init_es = __esm({
  "node_modules/@ant-design/fast-color/es/index.js"() {
    init_FastColor();
    init_types();
  }
});

// node_modules/@ant-design/colors/es/generate.js
function getHue(hsv, i, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i;
  } else if (i === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Math.round(saturation * 100) / 100;
}
function getValue(hsv, i, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i;
  } else {
    value = hsv.v - brightnessStep2 * i;
  }
  value = Math.max(0, Math.min(1, value));
  return Math.round(value * 100) / 100;
}
function generate(color) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = new FastColor(color);
  var hsv = pColor.toHsv();
  for (var i = lightColorCount; i > 0; i -= 1) {
    var c = new FastColor({
      h: getHue(hsv, i, true),
      s: getSaturation(hsv, i, true),
      v: getValue(hsv, i, true)
    });
    patterns.push(c);
  }
  patterns.push(pColor);
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _c = new FastColor({
      h: getHue(hsv, _i),
      s: getSaturation(hsv, _i),
      v: getValue(hsv, _i)
    });
    patterns.push(_c);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref) {
      var index = _ref.index, amount = _ref.amount;
      return new FastColor(opts.backgroundColor || "#141414").mix(patterns[index], amount).toHexString();
    });
  }
  return patterns.map(function(c2) {
    return c2.toHexString();
  });
}
var hueStep, saturationStep, saturationStep2, brightnessStep1, brightnessStep2, lightColorCount, darkColorCount, darkColorMap;
var init_generate = __esm({
  "node_modules/@ant-design/colors/es/generate.js"() {
    init_es();
    hueStep = 2;
    saturationStep = 0.16;
    saturationStep2 = 0.05;
    brightnessStep1 = 0.05;
    brightnessStep2 = 0.15;
    lightColorCount = 5;
    darkColorCount = 4;
    darkColorMap = [{
      index: 7,
      amount: 15
    }, {
      index: 6,
      amount: 25
    }, {
      index: 5,
      amount: 30
    }, {
      index: 5,
      amount: 45
    }, {
      index: 5,
      amount: 65
    }, {
      index: 5,
      amount: 85
    }, {
      index: 4,
      amount: 90
    }, {
      index: 3,
      amount: 95
    }, {
      index: 2,
      amount: 97
    }, {
      index: 1,
      amount: 98
    }];
  }
});

// node_modules/@ant-design/colors/es/presets.js
var presetPrimaryColors, red, volcano, orange, gold, yellow, lime, green, cyan, blue, geekblue, purple, magenta, grey, gray, presetPalettes, redDark, volcanoDark, orangeDark, goldDark, yellowDark, limeDark, greenDark, cyanDark, blueDark, geekblueDark, purpleDark, magentaDark, greyDark, presetDarkPalettes;
var init_presets = __esm({
  "node_modules/@ant-design/colors/es/presets.js"() {
    presetPrimaryColors = {
      "red": "#F5222D",
      "volcano": "#FA541C",
      "orange": "#FA8C16",
      "gold": "#FAAD14",
      "yellow": "#FADB14",
      "lime": "#A0D911",
      "green": "#52C41A",
      "cyan": "#13C2C2",
      "blue": "#1677FF",
      "geekblue": "#2F54EB",
      "purple": "#722ED1",
      "magenta": "#EB2F96",
      "grey": "#666666"
    };
    red = ["#fff1f0", "#ffccc7", "#ffa39e", "#ff7875", "#ff4d4f", "#f5222d", "#cf1322", "#a8071a", "#820014", "#5c0011"];
    red.primary = red[5];
    volcano = ["#fff2e8", "#ffd8bf", "#ffbb96", "#ff9c6e", "#ff7a45", "#fa541c", "#d4380d", "#ad2102", "#871400", "#610b00"];
    volcano.primary = volcano[5];
    orange = ["#fff7e6", "#ffe7ba", "#ffd591", "#ffc069", "#ffa940", "#fa8c16", "#d46b08", "#ad4e00", "#873800", "#612500"];
    orange.primary = orange[5];
    gold = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
    gold.primary = gold[5];
    yellow = ["#feffe6", "#ffffb8", "#fffb8f", "#fff566", "#ffec3d", "#fadb14", "#d4b106", "#ad8b00", "#876800", "#614700"];
    yellow.primary = yellow[5];
    lime = ["#fcffe6", "#f4ffb8", "#eaff8f", "#d3f261", "#bae637", "#a0d911", "#7cb305", "#5b8c00", "#3f6600", "#254000"];
    lime.primary = lime[5];
    green = ["#f6ffed", "#d9f7be", "#b7eb8f", "#95de64", "#73d13d", "#52c41a", "#389e0d", "#237804", "#135200", "#092b00"];
    green.primary = green[5];
    cyan = ["#e6fffb", "#b5f5ec", "#87e8de", "#5cdbd3", "#36cfc9", "#13c2c2", "#08979c", "#006d75", "#00474f", "#002329"];
    cyan.primary = cyan[5];
    blue = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
    blue.primary = blue[5];
    geekblue = ["#f0f5ff", "#d6e4ff", "#adc6ff", "#85a5ff", "#597ef7", "#2f54eb", "#1d39c4", "#10239e", "#061178", "#030852"];
    geekblue.primary = geekblue[5];
    purple = ["#f9f0ff", "#efdbff", "#d3adf7", "#b37feb", "#9254de", "#722ed1", "#531dab", "#391085", "#22075e", "#120338"];
    purple.primary = purple[5];
    magenta = ["#fff0f6", "#ffd6e7", "#ffadd2", "#ff85c0", "#f759ab", "#eb2f96", "#c41d7f", "#9e1068", "#780650", "#520339"];
    magenta.primary = magenta[5];
    grey = ["#a6a6a6", "#999999", "#8c8c8c", "#808080", "#737373", "#666666", "#404040", "#1a1a1a", "#000000", "#000000"];
    grey.primary = grey[5];
    gray = grey;
    presetPalettes = {
      red,
      volcano,
      orange,
      gold,
      yellow,
      lime,
      green,
      cyan,
      blue,
      geekblue,
      purple,
      magenta,
      grey
    };
    redDark = ["#2a1215", "#431418", "#58181c", "#791a1f", "#a61d24", "#d32029", "#e84749", "#f37370", "#f89f9a", "#fac8c3"];
    redDark.primary = redDark[5];
    volcanoDark = ["#2b1611", "#441d12", "#592716", "#7c3118", "#aa3e19", "#d84a1b", "#e87040", "#f3956a", "#f8b692", "#fad4bc"];
    volcanoDark.primary = volcanoDark[5];
    orangeDark = ["#2b1d11", "#442a11", "#593815", "#7c4a15", "#aa6215", "#d87a16", "#e89a3c", "#f3b765", "#f8cf8d", "#fae3b7"];
    orangeDark.primary = orangeDark[5];
    goldDark = ["#2b2111", "#443111", "#594214", "#7c5914", "#aa7714", "#d89614", "#e8b339", "#f3cc62", "#f8df8b", "#faedb5"];
    goldDark.primary = goldDark[5];
    yellowDark = ["#2b2611", "#443b11", "#595014", "#7c6e14", "#aa9514", "#d8bd14", "#e8d639", "#f3ea62", "#f8f48b", "#fafab5"];
    yellowDark.primary = yellowDark[5];
    limeDark = ["#1f2611", "#2e3c10", "#3e4f13", "#536d13", "#6f9412", "#8bbb11", "#a9d134", "#c9e75d", "#e4f88b", "#f0fab5"];
    limeDark.primary = limeDark[5];
    greenDark = ["#162312", "#1d3712", "#274916", "#306317", "#3c8618", "#49aa19", "#6abe39", "#8fd460", "#b2e58b", "#d5f2bb"];
    greenDark.primary = greenDark[5];
    cyanDark = ["#112123", "#113536", "#144848", "#146262", "#138585", "#13a8a8", "#33bcb7", "#58d1c9", "#84e2d8", "#b2f1e8"];
    cyanDark.primary = cyanDark[5];
    blueDark = ["#111a2c", "#112545", "#15325b", "#15417e", "#1554ad", "#1668dc", "#3c89e8", "#65a9f3", "#8dc5f8", "#b7dcfa"];
    blueDark.primary = blueDark[5];
    geekblueDark = ["#131629", "#161d40", "#1c2755", "#203175", "#263ea0", "#2b4acb", "#5273e0", "#7f9ef3", "#a8c1f8", "#d2e0fa"];
    geekblueDark.primary = geekblueDark[5];
    purpleDark = ["#1a1325", "#24163a", "#301c4d", "#3e2069", "#51258f", "#642ab5", "#854eca", "#ab7ae0", "#cda8f0", "#ebd7fa"];
    purpleDark.primary = purpleDark[5];
    magentaDark = ["#291321", "#40162f", "#551c3b", "#75204f", "#a02669", "#cb2b83", "#e0529c", "#f37fb7", "#f8a8cc", "#fad2e3"];
    magentaDark.primary = magentaDark[5];
    greyDark = ["#151515", "#1f1f1f", "#2d2d2d", "#393939", "#494949", "#5a5a5a", "#6a6a6a", "#7b7b7b", "#888888", "#969696"];
    greyDark.primary = greyDark[5];
    presetDarkPalettes = {
      red: redDark,
      volcano: volcanoDark,
      orange: orangeDark,
      gold: goldDark,
      yellow: yellowDark,
      lime: limeDark,
      green: greenDark,
      cyan: cyanDark,
      blue: blueDark,
      geekblue: geekblueDark,
      purple: purpleDark,
      magenta: magentaDark,
      grey: greyDark
    };
  }
});

// node_modules/@ant-design/colors/es/index.js
var es_exports2 = {};
__export(es_exports2, {
  blue: () => blue,
  blueDark: () => blueDark,
  cyan: () => cyan,
  cyanDark: () => cyanDark,
  geekblue: () => geekblue,
  geekblueDark: () => geekblueDark,
  generate: () => generate,
  gold: () => gold,
  goldDark: () => goldDark,
  gray: () => gray,
  green: () => green,
  greenDark: () => greenDark,
  grey: () => grey,
  greyDark: () => greyDark,
  lime: () => lime,
  limeDark: () => limeDark,
  magenta: () => magenta,
  magentaDark: () => magentaDark,
  orange: () => orange,
  orangeDark: () => orangeDark,
  presetDarkPalettes: () => presetDarkPalettes,
  presetPalettes: () => presetPalettes,
  presetPrimaryColors: () => presetPrimaryColors,
  purple: () => purple,
  purpleDark: () => purpleDark,
  red: () => red,
  redDark: () => redDark,
  volcano: () => volcano,
  volcanoDark: () => volcanoDark,
  yellow: () => yellow,
  yellowDark: () => yellowDark
});
var init_es2 = __esm({
  "node_modules/@ant-design/colors/es/index.js"() {
    init_generate();
    init_presets();
  }
});

export {
  require_classnames,
  _extends,
  init_extends,
  _typeof,
  init_typeof,
  isFragment,
  init_isFragment,
  warning,
  noteOnce,
  warning_default,
  init_warning,
  toPropertyKey,
  init_toPropertyKey,
  _defineProperty,
  init_defineProperty,
  _objectSpread2,
  init_objectSpread2,
  require_react_is,
  useMemo,
  init_useMemo,
  fillRef,
  composeRef,
  useComposeRef,
  supportRef,
  supportNodeRef,
  getNodeRef,
  init_ref,
  _arrayLikeToArray,
  init_arrayLikeToArray,
  _unsupportedIterableToArray,
  init_unsupportedIterableToArray,
  _arrayWithHoles,
  init_arrayWithHoles,
  _nonIterableRest,
  init_nonIterableRest,
  _slicedToArray,
  init_slicedToArray,
  canUseDom,
  init_canUseDom,
  contains,
  init_contains,
  removeCSS,
  updateCSS,
  init_dynamicCSS,
  _objectWithoutProperties,
  init_objectWithoutProperties,
  FastColor,
  es_exports,
  init_es,
  generate,
  presetPrimaryColors,
  gold,
  blue,
  presetPalettes,
  es_exports2,
  init_es2
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-7NK2GNZW.js.map
